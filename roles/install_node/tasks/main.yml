---

- name: Populate service facts
  service_facts:
- name: updated apt cache
  apt:
    update_cache: yes
- include_tasks: "{{ ansible_os_family | lower() }}_{{ ansible_distribution_major_version }}.yml"
  #when: ansible_facts.services['etny-vagrant.service'].state != 'running'
- name: Ubuntu 20.04 | enable_sgx dependencies
  apt:
    pkg:
      - make-guile
      - gcc
- name: Ubuntu 20.04 | build enable_sgx
  shell: make all -C sgx/
- name: Ubuntu 20.04 | run enable_sgx
  shell: sgx/sgx_enable
  register: sgx_register
- name: "Print message"
  debug:
    msg: '{{ sgx_register.stdout }}'
- name: SGX check reboot
  when: "('Software enable has been set.' in sgx_register.stdout) or ('The software enable has been performed on this system' in sgx_register.stdout)"
  debug:
    msg: "The software enabling procedure completed successfully."
- name: SGX reboot
  when: "('Software enable has been set.' in sgx_register.stdout) or ('The software enable has been performed on this system' in sgx_register.stdout)"
  copy:
    content: "yes"
    dest: /tmp/reboot
    mode: '0666'
- name: SGX reboot
  when: "('Software enable has been set.' in sgx_register.stdout) or ('The software enable has been performed on this system' in sgx_register.stdout)"
  meta: end_play
- name: Run SGX test and get EPC size
  shell: sudo utils/linux/test-sgx | grep "size of EPC section in Processor Reserved Memory" | sed 's/.*Memory, \(.*\) M/\1/' | grep -v "^0$"
  register: epc_size_output
  changed_when: false
- name: Print EPC size if available
  debug:
    msg: "EPC size is {{ epc_size_output.stdout }} M"
  when: epc_size_output.stdout | length > 0
- name: Check if EPC size is OK
  fail:
    msg: "EPC size for SGX is too low"
  when: epc_size_output.stdout|int < 64
- name: Determine SGX version support
  shell: sudo sudo utils/linux/test-sgx | awk '/sgx 1 supported/{sgx1=$NF} /sgx 2 supported/{sgx2=$NF} END {if (sgx1==1 && sgx2==0) {print "SGX version 1"} else if (sgx2==1) {print "SGX version 2"} else {print "SGX not available"}}'
  register: sgx_version_output
  changed_when: false
- name: Print SGX version support
  debug:
    msg: "{{ sgx_version_output.stdout }}"
- name: Check if VT-x is enabled
  command: kvm-ok
  register: vt_x_supported
  ignore_errors: true
- name: Fail the playbook if VT-x is not enabled
  fail:
    msg: "VT-x is not enabled. Make sure to enable VT-x and VT-d from BIOS."
  when: vt_x_supported.rc != 0
- name: Print VTx status
  debug:
    msg: "VTx enabled"
  when: vt_x_supported.rc == 0
- name: Check if VT-d is enabled
  shell: dmesg | grep DMAR
  register: vt_d_enabled
  ignore_errors: true
  no_log: true
  failed_when: false
- name: Print message if VT-d is not enabled
  debug:
    msg: "Warning! VT-d is not enabled. Check BIOS settings."
  when: vt_d_enabled.rc != 0
- name: apparmor - enable sgx support for libvirt qemu
  copy:
    src: ubuntu/etc/apparmor.d/libvirt/TEMPLATE.qemu
    dest: /etc/apparmor.d/libvirt/TEMPLATE.qemu
- name: fog-libvirt - install
  shell: vagrant plugin install fog-libvirt --plugin-version=0.9.0
- name: vagrant-libvirt - install
  shell: vagrant plugin install vagrant-libvirt --plugin-version=0.9.0
- name: vagrant-preload - install
  shell: vagrant plugin install vagrant-reload --plugin-version=0.0.1
- name: vagrant - get VM name
  shell: virsh list --name --all
  register: vagrant_vm_name
- name: vagrant - get VM name
  shell: virsh list --name --state-running
  register: vagrant_vm_name_running
- name: vagrant - cleanup VM
  shell: virsh shutdown {{ vagrant_vm_name.stdout }}
  when: 
    - vagrant_vm_name.stdout != ''
    - vagrant_vm_name_running.stdout != ''
- name: vagrant - cleanup VM
  shell: virsh undefine {{ vagrant_vm_name.stdout }}
  when: vagrant_vm_name.stdout != ''
- name: vagrant - cleanup VM
  shell: vagrant destroy -f
  #when: ansible_facts.services['etny-vagrant.service'].state != 'running'
- name: vagrant - provision VM
  shell: vagrant up --provider=libvirt
  #when: ansible_facts.services['etny-vagrant.service'].state != 'running'
- name: startup - set etny-vagrant configuration
  shell: echo "ETNY_PATH=${PWD}" > /etc/default/etny-vagrant
- name: Copy vagrant dir to root
  when: (ansible_facts['distribution'] == "Ubuntu" and ansible_facts['distribution_major_version'] == "18" and ansible_kernel is version('5.0.0-050000-generic','=='))
  copy:
    src: ~/.vagrant.d
    dest: /root
    force: yes
- name: startup - create etny-vagrant.service
  copy:
    src: etc/systemd/system/etny-vagrant.service
    dest: /etc/systemd/system/etny-vagrant.service
- name: startup - enable etny-vagrant.service
  shell: systemctl enable etny-vagrant.service
- name: startup - start etny-vagrant.service
  shell: systemctl restart etny-vagrant.service
- name: finished
  debug:
    msg: Ethernity NODE installation finished
